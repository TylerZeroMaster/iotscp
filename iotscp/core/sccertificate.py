# Certificate file specification:
# The first 10 bytes define the certificate version and the size of the key
#  Version  |      Segments       |    Segment length
# 0x00 0x00 | 0x00 0x00 0x00 0x00 | 0x00 0x00 0x00 0x00
#
# The rest of the file is the key itself, made up of random bytes generated by
# the OS's rng (urandom in Python). The length of the key is
# equal to Segments * Segment length

import os
import logging
from struct import pack, unpack

from . import CERTIFICATE_PATH

DEFAULT_SEGMENTS = 1000
DEFAULT_SEGMENT_LENGTH = 1000
SPEC_VERSION = (1, 0)

def _get_random_offset(segments, segment_length):
    from random import randint
    logging.debug("Generating random offset")
    return randint(0, segments - 1) * segment_length

def generate_certificate(segments, segment_length):
    """generate_certificate(segments_int, segment_length_int)

    Generate a new certificate with segments and segment_length.
    Each generated certificate is given a uuid.
    """
    from uuid import uuid1
    uuid = str(uuid1())
    print(''.join(("Creating new certificate with uuid ", uuid)))
    key_path = os.path.join(CERTIFICATE_PATH, uuid, "key.bin")
    key_size = segments * segment_length
    os.makedirs(os.path.dirname(key_path))
    with open(key_path, "wb") as bout:
        bout.write(pack("<BBII", SPEC_VERSION[0], SPEC_VERSION[1],
            segments, segment_length))
        bout.write(os.urandom(key_size))

class NullCertificateError(Exception):
    """This error is raised when the client sends an unknown uuid"""
    def __init__(self, uuid):
        self.value = "No valid certificate found for %s" % uuid

    def __str__(self):
        return repr(self.value)

class SCCertificate():
    """SCCertificate(uuid_str, [offset_int]) -> SCCertificate

    This class is used for storing information about and controlling access
    to certificates. A certificate is a string of os.urandom characters of
    arbitrary length.

    If the offset into the certificate is not given, this picks a random offset.

    The segments and segment_length parameters are used when generating a new
    certificate.
    """
    def __init__(self, uuid, offset=None):
        cert_info_sze = 10
        self.key_path = os.path.join(CERTIFICATE_PATH, uuid, "key.bin")
        self.uuid = uuid
        if not os.path.exists(self.key_path):
            raise NullCertificateError(uuid)
        with open(self.key_path, "rb") as _bin:
            cert_info = unpack("<BBII", _bin.read(cert_info_sze))
            version = cert_info[0:2]
            if version != SPEC_VERSION:
                raise NullCertificateError(uuid)
            self.segments, self.segment_length = cert_info[2:4]
            self.offset = offset or _get_random_offset(self.segments,
                self.segment_length) + cert_info_sze

    def get_key_segment(self):
        """get_key_segment() -> key_segment_str

        Read the certificate from offset to segment_length.
        This is only ever called once during the initialization of SCSession

        returns one segment of the certificate
        """
        with open(self.key_path, "rb") as _bin:
            _bin.seek(self.offset)
            return _bin.read(self.segment_length)
